/*
 * This file is part of the 
 *
 * Copyright (c) 2017-2018 linghaibin
 *
 */

#include "app_configure.h"
#include "stdio.h"
//lua
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include "string.h"
#include "ff.h"

#include <rt_sys.h>
///*
//** Message handler used to run all chunks
//*/
//static int msghandler (lua_State *L) {
//  const char *msg = lua_tostring(L, 1);
//  if (msg == NULL) {  /* is error object not a string? */
//    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
//        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
//      return 1;  /* that is the message */
//    else
//      msg = lua_pushfstring(L, "(error object is a %s value)",
//                               luaL_typename(L, 1));
//  }
//  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
//  return 1;  /* return the traceback */
//}


//static int docall (lua_State *L, int narg, int nres) {
//  int status;
//  int base = lua_gettop(L) - narg;  /* function index */
//  lua_pushcfunction(L, msghandler);  /* push message handler */
//  lua_insert(L, base);  /* put it under function and args */
//  //globalL = L;  /* to be available to 'laction' */
//  //signal(SIGINT, laction);  /* set C-signal handler */
//  status = lua_pcall(L, narg, nres, base);
//  //signal(SIGINT, SIG_DFL); /* reset C-signal handler */
//  lua_remove(L, base);  /* remove message handler from the stack */
//  return status;
//}

///*
//** Check whether 'status' is not OK and, if so, prints the error
//** message on the top of the stack. It assumes that the error object
//** is a string, as it was either generated by Lua or by 'msghandler'.
//*/
//static int report (lua_State *L, int status) {
//  if (status != LUA_OK) {
//    const char *msg = lua_tostring(L, -1);
//    //l_message("lua", msg);
//    lua_pop(L, 1);  /* remove message */
//  }
//  return status;
//}


//static int dochunk (lua_State *L, int status) {
//  if (status == LUA_OK) status = docall(L, 0, 0);
//  return report(L, status);
//}

// int dostring (lua_State *L, const char *s, const char *name) {
//  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
//}

#define MMCFS_MAX_FDS   4
static FIL mmcfs_fd_table[ MMCFS_MAX_FDS ];
static int mmcfs_num_fd;
static FATFS mmc_fs;
static FIL mmc_fileObject;
#define PATH_BUF_SIZE   40
static char mmc_pathbuf[PATH_BUF_SIZE];
int mmcfs_find_empty_fd( void )
{
    int i;

    for (i = 0; i < MMCFS_MAX_FDS; i ++)
    if (mmcfs_fd_table[i].fs == NULL)
    return i;
    return -1;
}

int mmc_open(const char * filename, int mode) {
    int fd;
    int mmc_mode;
    if (mmcfs_num_fd == MMCFS_MAX_FDS) {
        return -1;
    }
    mmc_pathbuf[0] = 0;
    if (strchr(filename, '/') == NULL)
    strcat(mmc_pathbuf, "/");
    strcat(mmc_pathbuf, filename);
    switch(mode) {
        case 0:mmc_mode=FA_OPEN_EXISTING|FA_READ;break;        //r
        case 2:mmc_mode=FA_OPEN_EXISTING|FA_READ|FA_WRITE;break;        //r+
        case 3:mmc_mode=FA_OPEN_ALWAYS|FA_READ;break;        //rb+
        case 4:mmc_mode=FA_CREATE_ALWAYS|FA_WRITE;    break;        //w
        case 5:mmc_mode=FA_OPEN_ALWAYS|FA_WRITE;break;        //wb
        case 6:mmc_mode=FA_CREATE_ALWAYS|FA_READ|FA_WRITE;break;        //w+
        case 7:mmc_mode=FA_OPEN_ALWAYS|FA_READ|FA_WRITE;break;        //wb+
        case 8:mmc_mode=FA_OPEN_ALWAYS|FA_WRITE;break;        //a
        case 0xa:mmc_mode=FA_OPEN_ALWAYS|FA_READ|FA_WRITE;break;         //a+
        case 0xb:mmc_mode=FA_OPEN_ALWAYS|FA_READ|FA_WRITE;break;         //ab+
        case 18:mmc_mode=FA_OPEN_ALWAYS|FA_READ|FA_WRITE;break;         //at+
    }

    printf("read: %s",mmc_pathbuf);
    // Open the file for reading
    if (f_open(&mmc_fileObject, mmc_pathbuf, mmc_mode) != FR_OK) {
        return -1;
    }
    if (mode & OPEN_A)
        mmc_fileObject.fptr = mmc_fileObject.fsize;
    fd = mmcfs_find_empty_fd();
    memcpy(mmcfs_fd_table + fd, &mmc_fileObject, sizeof(FIL));
    mmcfs_num_fd ++;
    return fd;      
}
int mmc_close(int handle) {
    FRESULT res;
    FIL* pfile = mmcfs_fd_table + handle;
    res=f_close( pfile );
    if(res==FR_OK) {
    memset(pfile, 0, sizeof(FIL));
    mmcfs_num_fd --;
    }
    return 0;
}

size_t mmc_write(int handle, const unsigned char * buffer, size_t size) {
    UINT bytes_written;
    if (f_write(mmcfs_fd_table + handle,  buffer, size, &bytes_written) != FR_OK) {
        return 0;
    }
    return (size_t) bytes_written;
}

size_t mmc_read(int handle, unsigned char * buffer, size_t size) {
    UINT bytes_read;
    if (f_read(mmcfs_fd_table + handle, buffer, size, &bytes_read) != FR_OK) {
        return 0;
    }
    return (size_t) bytes_read;
}

long mmc_lseek(int handle, long offset, int whence) {
    FIL* pfile = mmcfs_fd_table + handle;
    long newpos = 0;
    switch( whence ) {
        case SEEK_SET:
        // seek from beginning of file
        newpos = offset;
        break;
        case SEEK_CUR:
        // seek from current position
        newpos = pfile->fptr + offset;
        break;
        case SEEK_END:
        // seek from end of file
        newpos = pfile->fsize + offset;
        break;
        default:
        return -1;
    }
    if (f_lseek (pfile, newpos) != FR_OK)
        return -1;
    return newpos;
}

long mmc_file_len(int handle) {
    FIL* pfile = mmcfs_fd_table + handle;
    return pfile->fsize;
}

int mmcfs_init(void) {
    // Mount the MMC file system using logical disk 0
    if (f_mount(&mmc_fs,"1:",1) != FR_OK)
        return -1;
    else 
        return 0;
}


typedef int FILEHANDLE;
#pragma import(__use_no_semihosting_swi)
#pragma import(_main_redirection)
const char __stdin_name[150];
const char __stdout_name[150];
const char __stderr_name[150];


FILEHANDLE _sys_open(const char *name, int openmode) {
    return mmc_open(name, openmode);
}

int _sys_close(FILEHANDLE fh) {
    return mmc_close(fh);
}

int _sys_write(FILEHANDLE fh, const unsigned char *buf, unsigned len, int mode) {
    return mmc_write(fh, buf, len);
}

int _sys_read(FILEHANDLE fh, unsigned char*buf, unsigned len, int mode) {
    return mmc_read(fh, buf, len);
}

//检查句柄是否为终端
int _sys_istty(FILEHANDLE fh) {
    return 0;
}

int _sys_seek(FILEHANDLE fh, long pos) {
    return mmc_lseek(fh, pos, SEEK_SET);
}

//刷新句柄关联的缓冲区
int _sys_ensure(FILEHANDLE fh) {
    return 0;
}

//返回文件当前长度
long _sys_flen(FILEHANDLE fh) {
    return mmc_file_len(fh);
}

int _sys_tmpnam(char *name, int fileno, unsigned maxlength) {
    return 0;
}

//将一个字符写入控制台
void _ttywrch(int ch) {

}

int remove(const char *filename) {    
    return 0;
}

char *_sys_command_string(char *cmd, int len) {
    return 0;
}

int time(int *t) {  
    return 0;  
}

unsigned int clock(void) {
    return 0;
}

int system(const char* a) {
    return 0;
}

int rename(const char *a, const char *b) {
    return 0;
}
