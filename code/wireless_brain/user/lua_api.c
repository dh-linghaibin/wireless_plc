/*
 * This file is part of the 
 *
 * Copyright (c) 2017-2018 linghaibin
 *
 */
 
#include "stdio.h"
//lua
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include "string.h"
#include "ff.h"
/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}


static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  //globalL = L;  /* to be available to 'laction' */
  //signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  //signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    //l_message("lua", msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}


static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}

 int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}


typedef int FILEHANDLE;
//#pragma import(__use_no_semihosting_swi)
//#pragma import(_main_redirection)
const char __stdin_name[150];
const char __stdout_name[150];
const char __stderr_name[150];


FILEHANDLE _sys_open(const char *name, int openmode) {
    uint32_t mode = 0;  
    int ret;  
  
    if(openmode == 0)  
    {  
        mode |= FA_READ;  
    }  
    if(openmode & 0x01)  
    {  
        mode |= FA_WRITE;  
    }  
    if(openmode & 0x10)  
    {  
        mode |= FA_READ | FA_WRITE;  
    }  
    if(openmode & 0x0100)  
    {  
        mode |= FA_CREATE_NEW;  
    }  
    //ret = f_open(&sd_file, name,  mode);  
    if(ret != FR_OK)  
    {  
        return 0;  
    }  
    return 1;  
}

int _sys_close(FILEHANDLE fh) {
	return 0;
}

int _sys_write(FILEHANDLE fh, const unsigned char *buf, unsigned len, int mode) {
	return 0;
}

int _sys_read(FILEHANDLE fh, unsigned char*buf, unsigned len, int mode) {
	return 0;
}

int _sys_istty(FILEHANDLE fh) {
	return 0;
}

int _sys_seek(FILEHANDLE fh, long pos) {
	return 0;
}

int _sys_ensure(FILEHANDLE fh) {
	return 0;
}

long _sys_flen(FILEHANDLE fh) {
	return 0;
}

void _sys_exit(int status) {

}

int _sys_tmpnam(char *name, int fileno, unsigned maxlength) {
	return 0;
}

void _ttywrch(int ch) {

}

int remove(const char *filename) {	
	return 0;
}

char *_sys_command_string(char *cmd, int len) {
	return 0;
}

int time(int *t) {  
    return 0;  
}

unsigned int clock(void) {
	return 0;
}

int system(const char* a) {
	return 0;
}

int rename(const char *a, const char *b) {
	return 0;
}